/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#define STM32G070xx
#include "stm32g0xx.h"

uint8_t volatile g_button_pressed = 0;

void button_init ();
void EXTI4_15_IRQHandler (void);

int main (void) {
  RCC->IOPENR |= 0b1 << 0; // Enable PORTA
  GPIOA->MODER &= ~ (0b11 << (2*5)); // Clear MODE bits for 5th pin (PA-5)
  GPIOA->MODER |= 0b1 << (2*5); // Set MODE bits for 5th pin (PA-5) to 01 (set output)

  RCC->IOPENR |= 0b1 << 2; // Enable PORTC
  GPIOC->MODER &= ~ (0b11 << (2*13)); // Clear MODE bits for 13th pin (PC-13) (set input)

  button_init ();

  while (1) {
    if (g_button_pressed) {
      GPIOA->ODR ^= 0b1 << 5; // Toggle PA-5
      g_button_pressed = 0;
    }
    else {
      GPIOB->ODR |= 0b1 << 14; // Turn on PB-14
    }
  }
}

void button_init () {
  RCC->APBENR2 |= RCC_APBENR2_SYSCFGEN; // Enable SYSCFGEN
  EXTI->RTSR1 |= EXTI_RTSR1_RT13; // Enable interrupt on rising edge at EXTI line 13
  SYSCFG->EXTICR[3] |= EXTI_EXTICR4_EXTI13_Pos; // Set PC-13 as GPIO pin for interrupt
  EXTI->IMR1 |= EXTI_IMR1_IM13; // Unmask EXTI line 13
  NVIC_EnableIRQ(EXTI4_15_IRQn); // Enable interrupts for EXTI4_15
}

void EXTI4_15_IRQHandler (void) {
  g_button_pressed = 1;
  GPIOB->ODR &= ~ (0b1 << 14); // Turn off PB-14
  EXTI->RPR1 |= EXTI_RPR1_RPIF13; // Clear pending bit for line 13
}
