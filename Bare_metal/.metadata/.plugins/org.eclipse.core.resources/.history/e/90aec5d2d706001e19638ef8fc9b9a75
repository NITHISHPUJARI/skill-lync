/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include "stm32g070xx.h"
#include <stdio.h>
#include "ssd1315.h"




// Define I2C peripheral base address
#define I2C_BASE_ADDR 0x40005400

// I2C registers
#define I2C_CR1    (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x00))
#define I2C_CR2    (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x04))
#define I2C_OAR1   (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x08))
#define I2C_OAR2   (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x0C))
#define I2C_DR     (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x10))
#define I2C_SR1    (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x14))
#define I2C_SR2    (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x18))
#define I2C_CCR    (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x1C))
#define I2C_TRISE  (*(volatile uint32_t*)(I2C_BASE_ADDR + 0x20))

// BMP280 device address
#define BMP280_ADDR 0x76

// BMP280 registers
#define BMP280_REG_PRESS_MSB 0xF7
#define BMP280_REG_PRESS_LSB 0xF8
#define BMP280_REG_PRESS_XLSB 0xF9

// LIS3DH device address
#define LIS3DH_ADDR 0x18

// LIS3DH registers
#define LIS3DH_REG_OUT_X_L 0x28
#define LIS3DH_REG_OUT_X_H 0x29
#define LIS3DH_REG_OUT_Y_L 0x2A
#define LIS3DH_REG_OUT_Y_H 0x2B
#define LIS3DH_REG_OUT_Z_L 0x2C
#define LIS3DH_REG_OUT_Z_H 0x2D

// SSD1315 OLED display address
#define SSD1315_ADDR 0x3C

// SSD1315 registers
#define SSD1315_REG_CONTROL 0x00
#define SSD1315_REG_DATA 0x40

// Function to initialize I2C
void I2C_Init() {
    // Enable I2C peripheral clock
    RCC->AHBENR |= RCC_APBENR1_I2C1EN;

    // Configure I2C peripheral
    I2C_CR1 = 0x00000000;  // Disable I2C peripheral

    // Set I2C clock frequency
    I2C_CR2 = (6 << 0);  // PCLK1 = 8MHz, I2C frequency = 8MHz / (6+1) = 1.14MHz

    // Set I2C slave address
    I2C_OAR1 = (BMP280_ADDR << 1);  // Set BMP280 as slave address

    // Configure I2C rise time
    I2C_TRISE = 0x00000007;  // Maximum rise time value for 1000ns at 1.14MHz

    // Enable I2C peripheral
    I2C_CR1 |= I2C_CR1_PE;
}

// Function to start an I2C transmission
void I2C_StartTransmission(uint8_t deviceAddress, uint8_t mode) {
    // Wait until I2C bus is not busy
    while (I2C_SR2 & I2C_ISR_BUSY);

    // Generate start condition
    I2C_CR1 |= I2C_CR2_START;

    // Wait until start condition is generated
    while (!(I2C_SR1 & I2C_CR1_SBC));

    // Send device address with mode (read/write)
    I2C_DR = (deviceAddress << 1) | mode;

    // Wait until address is sent
    while (!(I2C_SR1 & I2C_ISR_ADDR));

    // Clear ADDR flag
    //volatile uint32_t temp = I2C_SR2;

    // Ensure that the start bit is cleared
    I2C_CR1 &= ~I2C_CR2_START;
}

// Function to stop an I2C transmission
void I2C_StopTransmission() {
    // Generate stop condition
    I2C_CR1 |= I2C_CR2_STOP;

    // Wait until stop condition is detected
    while (I2C_SR2 & I2C_SR2);
}

// Function to write a byte to the I2C bus
void I2C_WriteByte(uint8_t data) {
    // Write data to the I2C data register
    I2C_DR = data;

    // Wait until data transfer is complete
    while (!(I2C_SR1 & I2C_ISR_TXE));
}

// Function to read a byte from the I2C bus
uint8_t I2C_ReadByte() {
    // Enable I2C acknowledge
    I2C_CR1 |= I2C_CR2_NACK;

    // Wait until data is received
    while (!(I2C_SR1 & I2C_ISR_RXNE));

    // Read data from the I2C data register
    uint8_t data = I2C_DR;

    // Disable I2C acknowledge
    I2C_CR1 &= ~I2C_CR2_NACK;

    return data;
}

// Function to initialize the SSD1315 OLED display
void OLED_Init() {
    // Send control bytes to initialize OLED display
    I2C_StartTransmission(SSD1315_ADDR, 0);
    I2C_WriteByte(SSD1315_REG_CONTROL);
    I2C_WriteByte(0xAE);  // Display off
    I2C_WriteByte(0xD5);  // Set display clock divide ratio/oscillator frequency
    I2C_WriteByte(0x80);  // Recommended ratio for internal oscillator frequency
    I2C_WriteByte(0xA8);  // Set multiplex ratio
    I2C_WriteByte(0x3F);  // 1/64 duty
    I2C_WriteByte(0xD3);  // Set display offset
    I2C_WriteByte(0x00);  // No offset
    I2C_WriteByte(0x40);  // Set start line
    I2C_WriteByte(0x8D);  // Charge pump setting
    I2C_WriteByte(0x14);  // Enable charge pump
    I2C_WriteByte(0x20);  // Set memory addressing mode
    I2C_WriteByte(0x00);  // Horizontal addressing mode
    I2C_WriteByte(0xA1);  // Set segment re-map (column address 127 is mapped to SEG0)
    I2C_WriteByte(0xC8);  // Set COM output scan direction (reverse)
    I2C_WriteByte(0xDA);  // Set COM pins hardware configuration
    I2C_WriteByte(0x12);  // Alternative COM pin configuration, disable COM left/right remap
    I2C_WriteByte(0x81);  // Set contrast control
    I2C_WriteByte(0xCF);  // Contrast value
    I2C_WriteByte(0xD9);  // Set pre-charge period
    I2C_WriteByte(0xF1);  // Phase 1: 15 DCLK, Phase 2: 1 DCLK
    I2C_WriteByte(0xDB);  // Set VCOMH deselect level
    I2C_WriteByte(0x40);  // 0.77 x Vcc
    I2C_WriteByte(0xA4);  // Entire display on (resume from RAM content)
    I2C_WriteByte(0xA6);  // Set normal display
    I2C_WriteByte(0xAF);  // Display on
    I2C_StopTransmission();
}

// Function to write data to the SSD1315 OLED display
void OLED_WriteData(uint8_t data) {
    // Send data byte to OLED display
    I2C_StartTransmission(SSD1315_ADDR, 0);
    I2C_WriteByte(SSD1315_REG_DATA);
    I2C_WriteByte(data);
    I2C_StopTransmission();
}

// Function to read pressure from BMP280
int32_t BMP280_ReadPressure() {
    int32_t pressure = 0;

    // Start I2C transmission to BMP280
    I2C_StartTransmission(BMP280_ADDR, 0);
    I2C_WriteByte(BMP280_REG_PRESS_MSB);
    I2C_StopTransmission();

    // Read pressure data from BMP280
    I2C_StartTransmission(BMP280_ADDR, 1);
    pressure = (int32_t)(I2C_ReadByte() << 12);
    pressure |= (int32_t)(I2C_ReadByte() << 4);
    pressure |= (int32_t)(I2C_ReadByte() >> 4);
    I2C_StopTransmission();

    return pressure;
}

// Function to read accelerometer data from LIS3DH
void LIS3DH_ReadAccelerometer(int16_t* x, int16_t* y, int16_t* z) {
    // Start I2C transmission to LIS3DH
    I2C_StartTransmission(LIS3DH_ADDR, 0);
    I2C_WriteByte(LIS3DH_REG_OUT_X_L | 0x80);
    I2C_StopTransmission();

    // Read accelerometer data from LIS3DH
    I2C_StartTransmission(LIS3DH_ADDR, 1);
    *x = (int16_t)((I2C_ReadByte() | (I2C_ReadByte() << 8)) >> 4);
    *y = (int16_t)((I2C_ReadByte() | (I2C_ReadByte() << 8)) >> 4);
    *z = (int16_t)((I2C_ReadByte() | (I2C_ReadByte() << 8)) >> 4);
    I2C_StopTransmission();
}

// Font array for displaying characters (ASCII 32 to 127)
const uint8_t font[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // Space
    {0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00},  // !
    {0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00},  // "
    // Add more characters here...
    // Replace the remaining characters with the corresponding font data
};

// Function to display a character on the SSD1315 OLED display
void OLED_DisplayChar(char ch) {
    for (int i = 0; i < 8; i++) {
        OLED_WriteData(font[ch - 32][i]);
    }
}

// Function to display a string on the SSD1315 OLED display
void OLED_DisplayString(const char* str) {
    int i = 0;
    while (str[i] != '\0') {
        OLED_DisplayChar(str[i]);
        i++;
    }
}

// Function to display an integer on the SSD1315 OLED display
void OLED_DisplayInt(int num) {
    char buffer[10];
    sprintf(buffer, "%d", num);
    OLED_DisplayString(buffer);
}

int main() {
    // Initialize I2C
    I2C_Init();

    // Initialize OLED display
    OLED_Init();

    while (1) {
        // Read pressure from BMP280
        int32_t pressure = BMP280_ReadPressure();

        // Read accelerometer data from LIS3DH
        int16_t accelX, accelY, accelZ;
        LIS3DH_ReadAccelerometer(&accelX, &accelY, &accelZ);

        // Display data on OLED display
        I2C_StartTransmission(SSD1315_ADDR, 0);
        I2C_WriteByte(SSD1315_REG_CONTROL);
        I2C_WriteByte(0xB0);  // Set page addressing mode
        I2C_WriteByte(0x00);  // Set lower column address
        I2C_WriteByte(0x10);  // Set higher column address

        // Display pressure
        OLED_DisplayString("Pressure: ");
        OLED_DisplayInt(pressure);
        OLED_DisplayString(" Pa");

        // Move to next line
        I2C_StartTransmission(SSD1315_ADDR, 0);
        I2C_WriteByte(SSD1315_REG_CONTROL);
        I2C_WriteByte(0xB0 | 0x01);  // Set page addressing mode
        I2C_WriteByte(0x00);         // Set lower column address
        I2C_WriteByte(0x10);         // Set higher column address

        // Display accelerometer data
        OLED_DisplayString("AccelX: ");
        OLED_DisplayInt(accelX);
        OLED_DisplayString("    ");

        OLED_DisplayString("AccelY: ");
        OLED_DisplayInt(accelY);
        OLED_DisplayString("    ");

        OLED_DisplayString("AccelZ: ");
        OLED_DisplayInt(accelZ);
        OLED_DisplayString("    ");

        I2C_StopTransmission();

        // Delay before next reading
        for (int i = 0; i < 1000000; i++);
    }
}
