/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32g0xx.h"

#define SSD1315_I2C_ADDR 0x3C

void delay(uint32_t delay_ms) {
    // Delay implementation
    // Adjust the delay based on your system clock speed
    for (uint32_t i = 0; i < (delay_ms * 8000); i++) {
        __NOP();
    }
}

void i2c_init() {
    // Enable I2C1 clock
    RCC->APBENR1 |= RCC_APBENR1_I2C1EN;

    // Configure GPIO pins for I2C1
    // Assuming SCL is connected to PB6 and SDA is connected to PB7
    GPIOB->MODER &= ~(GPIO_MODER_MODE6 | GPIO_MODER_MODE7);
    GPIOB->MODER |= (GPIO_MODER_MODE6_1 | GPIO_MODER_MODE7_1);
    GPIOB->AFR[0] |= (4 << GPIO_AFRL_AFSEL6_Pos) | (4 << GPIO_AFRL_AFSEL7_Pos);

    // Initialize I2C1 peripheral
    I2C1->CR1 = 0; // Disable I2C1 before configuration
    I2C1->TIMINGR = 0x0010020A; // Set the desired timing (standard mode)
    I2C1->CR1 |= I2C_CR1_PE; // Enable I2C1
}

void i2c_start(uint8_t addr, uint8_t mode) {
    // Wait until the bus is idle
    while ((I2C1->ISR & I2C_ISR_BUSY) != 0);

    // Generate START condition
    I2C1->CR2 = (addr << 1) | I2C_CR2_START | mode;
    while ((I2C1->ISR & I2C_ISR_TXIS) == 0);
}

void i2c_stop() {
    // Generate STOP condition
    I2C1->CR2 |= I2C_CR2_STOP;
    while ((I2C1->ISR & I2C_ISR_STOPF) == 0);
    I2C1->ICR |= I2C_ICR_STOPCF;
}

void i2c_write_byte(uint8_t data) {
    // Write data byte
    I2C1->TXDR = data;
    while ((I2C1->ISR & I2C_ISR_TXE) == 0);
}

void ssd1315_init() {
    uint8_t init_commands[] = {
        0xAE,         // Display OFF
        0xD5, 0x80,   // Set display clock divide ratio/oscillator frequency
        0xA8, 0x3F,   // Set multiplex ratio (1 to 64)
        0xD3, 0x00,   // Set display offset
        0x40,         // Set display start line
        0xA1,         // Set segment re-map (column address 127 is mapped to SEG0)
        0xC8,         // Set COM output scan direction (remapped mode)
        0xDA, 0x12,   // Set COM pins hardware configuration
        0x81, 0xCF,   // Set contrast control
        0xD9, 0xF1,   // Set pre-charge period
        0xDB, 0x40,   // Set VCOMH deselect level
        0xA4,         // Entire display ON (resume to RAM content display)
        0xA6,         // Set normal display (non-inverted)
        0xAF          // Display ON
    };

    // Start I2C transmission
    i2c_start(SSD1315_I2C_ADDR, (uint8_t)I2C_CR2_AUTOEND);


    // Send initialization commands to SSD1315 OLED display
    for (uint32_t i = 0; i < sizeof(init_commands); i++) {
        i2c_write_byte(init_commands[i]);
    }

    // Stop I2C transmission
    i2c_stop();
}

void ssd1315_write_data(uint8_t* data, uint32_t len) {
    // Start I2C transmission
    i2c_start(SSD1315_I2C_ADDR, 0);

    // Send data to SSD1315 OLED display
    for (uint32_t i = 0; i < len; i++) {
        i2c_write_byte(data[i]);
    }

    // Stop I2C transmission
    i2c_stop();
}

int main(void) {
    // System initialization
   // SystemInit();

    // Initialize I2C peripheral
    i2c_init();

    // Initialize SSD1315 OLED display
    ssd1315_init();

    // Example: Write "Hello, world!" to the display
    uint8_t hello_world[] = {
        0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21
    };
    ssd1315_write_data(hello_world, sizeof(hello_world));

    while (1) {
        // Main program loop
    }
}
