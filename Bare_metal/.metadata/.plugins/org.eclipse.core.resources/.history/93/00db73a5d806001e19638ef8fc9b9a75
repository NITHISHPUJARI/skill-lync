/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32g0xx.h"

#define BMP280_ADDRESS 0x76

void delay_ms(uint32_t ms) {
    // Implementation of delay function
    // Adjust according to your microcontroller's clock frequency
    uint32_t delayTicks = (SystemCoreClock / 1000) * ms;
    volatile uint32_t i;
    for (i = 0; i < delayTicks; i++);
}

void I2C_Init() {
    // Initialize I2C1 peripheral for communication with BMP280
    RCC->IOPENR |= RCC_APBENR1_I2C1EN; // Enable I2C1 clock
    RCC->APBENR1 |= RCC_APBENR1_USART2EN; // Enable USART2 clock
    GPIOA->MODER &= ~(GPIO_MODER_MODE9 | GPIO_MODER_MODE10); // Clear mode bits
    GPIOA->MODER |= (GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1); // Set alternate function mode
    GPIOA->AFR[1] &= ~(GPIO_AFRH_AFSEL9 | GPIO_AFRH_AFSEL10); // Clear alternate function bits
    GPIOA->AFR[1] |= (0x04 << GPIO_AFRH_AFSEL9_Pos) | (0x04 << GPIO_AFRH_AFSEL10_Pos); // Set alternate function I2C1

    I2C1->CR1 &= ~I2C_CR1_PE; // Disable I2C1 peripheral
    I2C1->TIMINGR = (0x10 << I2C_TIMINGR_PRESC_Pos) |
                    (0x13 << I2C_TIMINGR_SCLL_Pos) |
                    (0x0F << I2C_TIMINGR_SCLH_Pos) |
                    (0x02 << I2C_TIMINGR_SDADEL_Pos) |
                    (0x04 << I2C_TIMINGR_SCLDEL_Pos); // Set I2C timings
    I2C1->CR1 |= I2C_CR1_PE; // Enable I2C1 peripheral
}

void I2C_Start() {
    // Generate I2C start condition
    I2C1->CR2 |= I2C_CR2_START; // Set start bit
    while (!(I2C1->ISR & I2C_ISR_TXIS)); // Wait until TXIS flag is set
}

void I2C_Stop() {
    // Generate I2C stop condition
    I2C1->CR2 |= I2C_CR2_STOP; // Set stop bit
    while (I2C1->CR2 & I2C_CR2_STOP); // Wait until stop bit is cleared
}

void I2C_Write(uint8_t data) {
    // Write a byte to I2C bus
    I2C1->TXDR = data; // Write data to transmit data register
    while (!(I2C1->ISR & I2C_ISR_TXIS)); // Wait until TXIS flag is set
}

uint8_t I2C_ReadAck() {
    // Read a byte from I2C bus and send ACK
    while (!(I2C1->ISR & I2C_ISR_RXNE)); // Wait until RXNE flag is set
    uint8_t data = I2C1->RXDR; // Read data from receive data register
    I2C1->CR2 |= I2C_CR2_ACK; // Send ACK
    return data;
}

uint8_t I2C_ReadNack() {
    // Read a byte from I2C bus and send NACK
    while (!(I2C1->ISR & I2C_ISR_RXNE)); // Wait until RXNE flag is set
    uint8_t data = I2C1->RXDR; // Read data from receive data register
    I2C1->CR2 &= ~I2C_CR2_ACK; // Send NACK
    return data;
}

void BMP280_Init() {
    // Initialize BMP280 sensor
    I2C_Start();
    I2C_Write(BMP280_ADDRESS << 1); // Write device address
    I2C_Write(0xF4); // Write control measurement register address
    I2C_Write(0x27); // Write control measurement value (oversampling x4, normal mode)
    I2C_Stop();
}

int32_t BMP280_ReadTemperature() {
    // Read temperature from BMP280 sensor
    I2C_Start();
    I2C_Write(BMP280_ADDRESS << 1); // Write device address
    I2C_Write(0xFA); // Write temperature MSB register address
    I2C_Stop();

    I2C_Start();
    I2C_Write((BMP280_ADDRESS << 1) | 0x01); // Write device address with read bit
    int32_t temperature = (I2C_ReadAck() << 12) | (I2C_ReadAck() << 4) | (I2C_ReadNack() >> 4);
    I2C_Stop();

    return temperature;
}

int32_t BMP280_ReadPressure() {
    // Read pressure from BMP280 sensor
    I2C_Start();
    I2C_Write(BMP280_ADDRESS << 1); // Write device address
    I2C_Write(0xF7); // Write pressure MSB register address
    I2C_Stop();

    I2C_Start();
    I2C_Write((BMP280_ADDRESS << 1) | 0x01); // Write device address with read bit
    int32_t pressure = (I2C_ReadAck() << 12) | (I2C_ReadAck() << 4) | (I2C_ReadNack() >> 4);
    I2C_Stop();

    return pressure;
}

int main(void) {
    // System initialization

    I2C_Init();
    BMP280_Init();

    while (1) {
        int32_t temperature = BMP280_ReadTemperature();
        int32_t pressure = BMP280_ReadPressure();

        // Process temperature and pressure values as required

        delay_ms(1000); // Delay between measurements
    }
}
